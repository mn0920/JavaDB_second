package Day1;

public class OperatorEx1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		System.out.println("자료형변환과 산술연산자");
		
		int num1 = 10, num2 = 3;
		double res = 0.0;
		res = (double)(num1 + num2);
		/* (double)(num1 + num2) = 앞의 double이 생략된 것 : 자동 자료형 변환
		 * 그래서 결과값 도출된 것이 소수점 자리도 나오는 것.
		 * */
		System.out.println("num1 + num2 : " + res);
		
		res = num1 - num2;
		System.out.println("num1 - num2 : " + res);
		
		res = num1 * num2;
		System.out.println("num1 * num2 : " + res);
		
		res = (double)num1 / num2;
		/* num1을 임시로 실수로 바꿈 = 명시적 자료형 변환
		 * 자료형변환 종류 : 명시적 자료형변환, 자동 자료형 변환
		 *  */
		System.out.println("num1 / num2 : " + res);
		/*수학에서도 0으로 나눌 수 없듯이, 코드상에서도 0으로 나눌 수 없기
		 * 때문에 에러가 뜬다.
		 * int : 자료형 : 정수
		 * 나누기 할때, 정수 나누기 정수를 하여 소수점이 사라진다.
		 * double은 15자리까지 보장하기 때문에, 16번째 값은 보장을 하지 못한다.
		*/
		res = num1 % num2;
		System.out.println("num1 % num2 : " + res);
		/* % : 산술연산자 (모두연산자)
		 * 나머지를 구할 때 많이 사용한다. : 짝 수 홀 수 구할 때.*/
		
		num1 = (int)res;
		/* 정수 = 실수로 불가,
		 * 그리하여 명시적 자료형변환을 이용하여 가능하게 만든 것이다.
		*/
		
		// 자동 자료형 변환이 되는 흐름이 있다. 어떤 것은 되고 어떤 것은 안 되는 식으로.

		
		
		// 비교연산자 : 크거나 작거나 같다를 보는 연산자.
		// 비교연산자 : 결과가 참 또는 거짓을 반환
		boolean isPositive = false;
		// = false 이건 아무 뜻 없고 그냥 초기화 한 것임.
		num1 = 20;
		isPositive = num1 >= 0;
		System.out.println("num : " + num1 + ",양수 : " + isPositive);
		// 크거나 같다 : >= (O) / => (X)
		// 작거나 같다 : <= (O) / =< (X)
		
		boolean isSame = false;
		isSame = num1 == 10;
		// 같은지 아닌지 비교할 때는 '==' 사용한다.
		// = : 이것은 대입이라는 뜻.
		System.out.println("num1 : " + num1 + ", 10과 같음 : " + isSame);
		
		boolean isDiffent = false;
		isDiffent = num1 != 10;
		// != : 같지 않다.
		System.out.println("num1 :" + num1 + ",10과 다름 : " + isDiffent);

		
		/* 논리연산자 : 참과 거짓을 판별할 때 사용한다.
		            : 결과가 true 아니면 false
		   - 논리연산자의 특징 : 논리 연산자를 기준으로 좌, 우에 조건식이 들어가야함.
		   - 조건식 : 참과 거짓으로 나뉘는 식.
		   - 논리연산자는 보통 비교연산자랑 같이 온다.
		   - (비교연산자를 이용한 식) 논리연산자 (비교연산자를 이용한 식) 이런식으로 보통 온다.
		   - 논리연산자 기호 : &&(그리고), ||(또는), !(아니다)
		*/
		num1 = 30;
		/* 0 <= num1 <= 100
		 * 컴퓨터는 이를 인식하지 못한다. 그리하여 아래와 같은 방식으로 많이 쓴다.
		 * num1이 0보다 크거나 같고, num1이 100보다 작거나 같다.
		 * 만약 num1이 101이라면, false가 뜬다.
		 *        && : 둘 다 참일때에만 참. 하나라도 거짓이면 거짓.
		 * num1이 0보다 크거나 같거나, num1이 100보다 작거나 같다.
		 * 만약 num1이 101이라면, true가 뜬다. 왜냐하면 앞에 조건을 만족했으니까.
		 *        || : 둘다 거짓일 때만 거짓, 하나라도 참이면 참.
		 *         ! : 참이면 거짓으로, 거짓이면 참으로.
		 *         진리표라는 것이 있음 ㅇㅅㅇ
		 */
		boolean isScore = 0 <= num1 && num1 <= 100;
		System.out.println(num1 + "은 유효한 성적인가 : " + isScore);
		boolean isNot = !false;
		System.out.println("!false " + isNot);
		
		/* 유사한 연산자
		 * - 비트 논리 연산자 : 두 변수를 비트로 나열한 후 각 비트 별로 논리 연산을 한다.
		 * 결과는 true, false가 아닌 변수 값이 나온다.
		 * 임베디드 프로그램에서 주로 사용하는 연산자이다.
		 * &(그리고), |(또는), ~(아니다), ^(배타)
		 */
		
		num1 = 7;
		num2 = 10;
		int num3 = 7&10;
		//  7 : 00000000 00000000 00000000 00000111 / 뒤에서 부터 1,2,4,8, 이케 올라간다.
		// 10 : 00000000 00000000 00000000 00001010
		//  2 : 00000000 00000000 00000000 00000010
		// 참은 1. 그리하여 둘다 1일 경우에만 참.
		// 왜냐하면 int는 4비트이기 때문에 바이트가 32개.
		// 무슨 소리인지 1도 모르겠다.
		System.out.println("7&10 : " + num3);

		num3 = 7|10;
		//  7 : 00000000 00000000 00000000 00000111
		// 10 : 00000000 00000000 00000000 00001010
		// 15 : 00000000 00000000 00000000 00001111
		// | 이 연산은 하나라도 1이 있으면 1이 나온다.
		System.out.println("7|10 : " + num3);
		
		num3 = 7^10;
		//  7 : 00000000 00000000 00000000 00000111
		// 10 : 00000000 00000000 00000000 00001010
		// 13 : 00000000 00000000 00000000 00001101
		// ^ : 배타논리연산, exclusive, 서로 다르면 1, 같으면 0.
		System.out.println("7|10 : " + num3);
		
		num3 = ~7;
		//     7 : 00000000 00000000 00000000 00000111
		// ~7(8) : 11111111 11111111 11111111 11111000
		// 음수에서 양수로 넘어갈때,                -1
		// 0이라면 위에서 1을 계속 빌려온다.
		//       : 11111111 11111111 11111111 11110111
		//       : 00000000 00000000 00000000 00001000
		// | 이 연산은 하나라도 1이 있으면 1이 나온다.
		System.out.println("~7 : " + num3);
		
		//""는 실제로 찍히는 문자열, +num3는 넘버3가 갖고있는 문자열을 ""뒤에 가져다가 넣어준다.
		// ""안에 있는 것을 실제로 출력해서 보내준다. 그리고 명령어는 그 변수의 결과값을 보여주는 것.
		
		System.out.println(7+4);
		//7+4를 한 루 계산 결과를 출력
		
		System.out.println(""+7+4);
		//""+7을 해서 "7"이 만들어지고,
		//그 후, "7"+4를 해서 "74"가 만들어짐
			
			
		 /*비트 쉬프트 연산자 : 비트를 이동시킴
		 * >>, << 
		 * */
		 num1 = 15;
		 //    15 : 00000000 00000000 00000000 00001111
		
		 num3 = num1 << 2;
		 //       : 00000000 00000000 00000000 00111100
		 System.out.println("15 << 2 : " + num3);
			 
		 num1 = 15;
		 num3 = num1 << 1;
		 //       : 00000000 00000000 00000000 00011110
		 System.out.println("15 << 1 : " + num3);
			 
		 num1 = 15;
		 num3 = num1 << 3;
		 //       : 00000000 00000000 00000000 01111000
		 System.out.println("15 << 3 : " + num3);
		 // 왼쪽으로 한 칸 밀 면, 곱하기 2의 효과.(다 제곱으로 곱하는 것.)
		 // 오른쪽으로 한 칸 밀 면, 나누기 2의 효과.
		 // 떨어지는 것은 버리는 ㅎ과가 있다.
		 
			 
		 //증감연산자 " ++, --
		 // ++ : 월래 값에서 1이 증가
		 // -- : 월래 값에서 1이 감소.
		 // ++변수명(전위형), 변수명++(후위형)
		 /* 전위형과 후위형은 과정에서 차이나지, 결과에서 차이가 나진 않는다.
		  * 전위형 : 증가 후 동작(대입연산, 화면에 출력)
		  * 후위형 : 동작 후 증가
		  * */ 
		 num1 = 10;
		 num1++;
		 System.out.println("계산후 후위형 num1 : " + num1);
			 
		 num1 = 10;
		 ++num1;
		 System.out.println("계산후 전위형 num1 : " + num1);
			 
		 num1 = 10;
		 System.out.println("계산중 후위형 num1 : " + num1++);
		 System.out.println("계산중 후위형 num1 : " + num1);

		 num1 = 10;
		 System.out.println("계산중 전위형 num1 : " + ++num1);
			 
			 
		 /* 조건 선택연산자(삼항연산자 : 선택이 3개 필요하다.)
		  * 조건 선택연산자는 나중에 '조건문'으로 대체 가능하다.
		  * (조건식)?(값1):(값2)
		  * 조건식이 참이면 값1을, 거짓이면 값2을 활용한다.
		  * */
		 System.out.println((10%2==0)?"짝수":"홀수");
		
		 // 10을 2로 나누었을 때, 0이라면 값1을 아니라면 값2를 띄워주어라.
			 
			 
		 /* 결합연산자 : 축약형
		  * num1 = num1 + 2;
		  * num1 += 2;
		  * += : 위에것을 축약한 것.
		  * num1 = num1 << 1;
		  * num1 <<= 1;
		  * */
			 
			 
		// shift+tab : shift를 하나 지우는 효과가 있다.
			 
			 
			 
	}

}
